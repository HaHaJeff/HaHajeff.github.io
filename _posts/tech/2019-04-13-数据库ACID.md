---
?layout: post
title: 数据库中的ACID
category: 技术
tags: [数据库]
keywords: 数据库, ACID
---

---



# ACID

## Atomicity

原子性是指一个事务是不可分割的工作单位，其中的操作要么都做，要么都不做。

以银行转账为案列，要么转账成功，要么失败，不存在中间的状态，如果不保证原子性，那么A转账成功，扣款50元，B增加50元失败，系统无故丢失50元。

数据库是如何保证原子性的？

通过undo日志，即在操作执行前，先记录原先的记录状态。例如A账户本来有100元，B账户100元，在执行转账前前记录undo日志

```
<T1, a, 100>
<T1, b, 100>
```

然后执行操作，假设A扣款成功，B增加失败，那么事务执行失败，需要回滚，均能得到正确的余额，保证了正确性。

## Isolation

隔离性是指在并发执行事务的时候，不同事务之间互不干扰。

依旧以银行转账为例，A账户余额100，B账户余额100，A向B发起两次转账，每次50，在两次事务中分别执行，如果不保证隔离性，可能会出现如下情况：

| 事务T1                                          | 事务T2                                          |
| ----------------------------------------------- | ----------------------------------------------- |
| 读取A账户余额为100                              |                                                 |
| A账户执行转账操作，扣款50(提前做好undo日志)     |                                                 |
| 更新A账户余额(A账户余额为50)                    |                                                 |
| 读取B账户余额为100                              |                                                 |
| B账户执行增加余额操作，增加50(提前做好undo日志) |                                                 |
|                                                 | 读取A账户余额为150                              |
|                                                 | A账户执行转账操作，扣款50(提前做好undo日志)     |
|                                                 | 更新A账户余额(A账户余额为0)                     |
|                                                 | 读取B账户余额为100                              |
|                                                 | B账户执行增加余额操作，增加50(提前做好undo日志) |
|                                                 | 更新B账户余额(B账户余额为150)                   |
| 更新B账户余额(B账户余额为150)                   |                                                 |

A账户扣款两次成功，但是B账户却只完成一次入账操作，导致不一致。

如何保证隔离性呢？

通过上述操作发现，在T1和T2中都会公共资源进行读写操作，最简单的办法就是加排他锁(悲观锁)实现，当然这种方式效率是比较低下的，隔离性等级比较复杂，下回再议。

## Duration

持久性是指事务一旦提交，那么它对数据库的改变就是永久性的。

还是银行转账案例，在更新A账户余额那一步需要将内存中的变更操作持久化到磁盘，也就是说在提交事务之前一定要先将内存中的修改数据刷新到磁盘，如果不刷入磁盘，那么可能面临一个问题，事务提交成功，但是内存中数据失效了，却又没有持久化到磁盘，所以出现数据丢失。但是这种方式的效率会很低下，因为刷盘的单位是page，尽管只修改了一个byte，也需要刷入一个page。

如何解决持久性问题？

采用redo log解决上面的问题，当数据修改的时候，不仅仅在内存中修改，还会在redo log中记录变更操作。在事务提交的时候强制redo log提交，这样保证事务恢复的时候能够将没有刷入磁盘中的内存数据进行重建。



## undo redo

1. 为什么需要undo?
   1. 假设在提交事务之前，内存中的数据不落盘，那么其实也就不需要undo日志了，因为事务运行失败，内存数据失效，更改没有成功。**这叫no steal**
2. 为什么需要redo?
   1. 假设在提交事务的时候将修改强制刷盘，那么其实也就不需要redo日志了，因为事务提交成功，数据也全部得到的更新。**这叫force**

steal指的是在事务完成之前偷偷摸摸的将修改操作落盘，force指的是在事务提交的时候强制落盘修改操作。其实redo undo的真正目的就是看你的操作steal还是force的，如果是force no steal，那么不需要undo以及redo日志，但是效率很慢，在提交事务的时候需要阻塞很长的时间。
